import os
import csv
from re import sub, compile
import json
from datetime import datetime
from csv import reader as read_csv
from multiprocessing import Process, Pipe

import numpy as np
import base64

currency_to_rub = {
    "AZN": 35.68,
    "BYR": 23.91,
    "EUR": 59.90,
    "GEL": 21.74,
    "KGS": 0.76,
    "KZT": 0.13,
    "RUR": 1,
    "UAH": 1.64,
    "USD": 60.66,
    "UZS": 0.0055,
}




class Stat:
    salary_by_year = {}
    vacancy_by_year = {}
    salary_prof = {}
    prof_by_year = {}
    salary_by_city = {}
    precent_by_city = {}

    def __init__(self, sby, vby, sp, pby, sbc, pbc):
        self.salary_by_year = sby
        self.vacancy_by_year = vby
        self.salary_prof = sp
        self.prof_by_year = pby
        self.salary_by_city = sbc
        self.precent_by_city = pbc


class Vacancy:
    name = ''
    salary_from = 0.0
    salary_to = 0.0
    salary_currency = ''
    area_name = ''
    published_at = '1'

    def __init__(self, vac):
        self.name = vac['name']
        # print(salary_from)
        self.salary_from = float(vac['salary_from'])
        self.salary_to = float(vac['salary_to'])
        self.salary_currency = vac['salary_currency']
        self.area_name = vac['area_name']
        self.published_at = vac['published_at']


def read_file(file_name, prof):
    rows = list()
    vacancies = list()
    prof = prof.lower()
    file = open(file_name, 'r', encoding='utf-8-sig')
    file_reader = csv.reader(file, delimiter=",")
    count = 0
    columns = []
    salary = 0.0
    count = 0
    salary_prof = 0
    prof_count = 0
    city = dict()
    year = ''
    for row in file_reader:
        if count == 0:
            columns = row
            count = count + 1
            continue
        if "" in row or len(row) != len(columns):
            continue
        current = {}
        for i in range(len(row)):
            current[columns[i]] = row[i]
        vac =Vacancy(current)
        if year == '':
            year = vac.published_at.split('-')[0]
        middle_current_salary = (vac.salary_to + vac.salary_from)*currency_to_rub[vac.salary_currency]/2.0
        salary += middle_current_salary
        count += 1
        if vac.name.__contains__(prof):
            salary_prof += middle_current_salary
            prof_count += 1
        if city.__contains__(vac.area_name):
            city[vac.area_name][0] += middle_current_salary
            city[vac.area_name][1] += 1
        else:
            city[vac.area_name] = [middle_current_salary,1]
    #возвращаем текущий год, среднюю зп, количество вакансий, средняя зп по профессии, количество вакансий по профессии, статистику по городам
    return [year, int(salary/count), count, int(salary_prof/prof_count), prof_count,city]

def multiprocessing_file_read(connection, filename, prof):
    middle_salary= read_file(filename, prof)
    #отправляем полученную статистику процессу-родителю
    connection.send(middle_salary)
    connection.close()
if __name__ == '__main__':
    path_data = input('Введите путь до дирректории: ')
    prof = input('Введите название профессии: ')
    results = list()
    list_connection = list()
    proc_stat = list()
    salary_by_year = dict()
    vacancies_by_year = dict()
    salary_by_prof = dict()
    vacancies_by_prof = dict()
    vacancies_by_city = dict()
    vacancies_by_city_norm = dict()
    vacancies_by_city_precent = dict()
    all_vac = 0
    #запускаем процессы
    for i in os.listdir(path_data):
        parent_conn, child_conn = Pipe()
        list_connection.append(parent_conn)
        path = path_data + '\\' + i
        p = Process(target=multiprocessing_file_read, args=(child_conn, path, prof))
        p.start()
    #собираем результаты с каждого процесса
    for conn in list_connection:
        results.append(list(conn.recv()))
    #объединяем результаты с каждого процесса
    for result in results:
        salary_by_year[result[0]] = result[1]
        vacancies_by_year[result[0]] = result[2]
        salary_by_prof[result[0]] = result[3]
        vacancies_by_prof[result[0]] = result[4]
        current_stat_cities = result[5]
        #обрабатываем полученную статистику по городам
        for city in current_stat_cities:
            if vacancies_by_city.__contains__(city):
                vacancies_by_city[city][0] += current_stat_cities[city][0]
                vacancies_by_city[city][1] += current_stat_cities[city][1]
                all_vac += current_stat_cities[city][1]
            else:
                vacancies_by_city[city] = current_stat_cities[city]
                all_vac += current_stat_cities[city][1]
    #подсчитываем среднюю зарплату по городам и процент в каждом городе
    for city in vacancies_by_city:
        if vacancies_by_city[city][1]*100.0/all_vac >= 1:
            pr = round(vacancies_by_city[city][1] * 1.0 / all_vac, 4)
            vacancies_by_city_precent[city] = pr
            vacancies_by_city_norm[city] = int(vacancies_by_city[city][0] * 1.0 / vacancies_by_city[city][1])
    #выбираем первые 10 городов по значению зарплаты и проценту вакансий
    list_vac_norm =  list(dict(sorted(vacancies_by_city_norm.items(), key=lambda item: item[1], reverse=True)).items())[0:10]
    list_precent_norm = list(dict(sorted(vacancies_by_city_precent.items(), key=lambda item: item[1], reverse=True)).items())[0:10]
    print('Динамика уровня зарплат по годам:', salary_by_year)
    print('Динамика количества вакансий по годам:', vacancies_by_year)
    print('Динамика уровня зарплат по годам для выбранной профессии:', salary_by_prof)
    print('Динамика количества вакансий по годам для выбранной профессии:', vacancies_by_prof)
    print('Уровень зарплат по городам (в порядке убывания):', dict(list_vac_norm))
    print('Доля вакансий по городам (в порядке убывания):', dict(list_precent_norm))


